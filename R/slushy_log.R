#' @title Create log for slushy environment
#'
#' @description
#' The `slushy_log` function provides an overview of the package environment, 
#' including package usage, dependencies, and mismatches in comparison to the set of approved packages and selected snapshot date. It runs 
#' `renv::diagnostics` by default and can generate a custom report comparing 
#' library, lockfile, and package usage details.
#'
#' @param project Character. Path to the project directory. Defaults to the root of the project if `NULL`.
#' @param config List. The configuration object retrieved from `get_config()` that includes the `pkgs` list.
#' @param full_report Logical. If `TRUE`, generates a full report by running `renv::diagnostics` in addition to the summarized report. Defaults to `FALSE`.
#'
#' @details
#' This function inspects the following aspects of the package environment:
#' \itemize{
#'   \item Synchronization between the local environment and `renv` lockfile.
#'   \item Alignment of installed packages versus available versions in the CRAN snapshot.
#'   \item Usage of agreed upon packages (i.e., those listed in the `DESCRIPTION` file) in code.
#'   \item Changes to set of agreed upon packages. The config file is referenced for the original set of agreed upon packages, and the `DESCRIPTION` file is referenced for the current set of agreed upon packages. 
#'   \item Report use of any packages outside the agreed-upon set (in `DESCRIPTION`).  
#' }
#'
#' If `full_report` is `TRUE`, a more detailed report is generated by running `renv::diagnostics` in addition to the summarized package diagnostic.
#'
#' @return Invisible `NULL`. Outputs details in the console. The function generates either a summarized or full report.
#' 
#' @examples
#' \dontrun{
#' # Generate a summarized package diagnostic report
#' slushy_log(config = get_config("slushy_config.yml"), project = "/path/to/project", full_report = FALSE)
#'
#' # Generate a full package diagnostic report with `renv::diagnostics`
#' slushy_log(config = get_config("slushy_config.yml"), project = "/path/to/project", full_report = TRUE)
#' }
#'
#' @export
#'
#' @importFrom renv status diagnostics paths dependencies
#' @importFrom dplyr pull left_join filter mutate rename select setdiff
#' @importFrom tibble as_tibble
#' @importFrom cli cli_alert_info cli_alert_success cli_alert_warning cli_h3 cli_text cli_ul cat_line
#' @importFrom stringr str_detect
#' @importFrom utils installed.packages available.packages
#' 
slushy_log <- function(project = NULL, config = get_config(), full_report = FALSE) { 
  if (is.null(project)) {
    project <- proj_root()
  }
  
  #----------------------------- LIBRARY VS LOCK -------------------------------
  
  # Extract list of packages in library and lock file
  renv_status <- quietly(status)(project = project)$result
  
  library_df <- lst_to_df(renv_status$library$Packages)
  lockfile_df <- lst_to_df(renv_status$lockfile$Packages)
  
  library_df_pkgs <- library_df %>% pull(Package)
  lockfile_df_pkgs <- lockfile_df %>% pull(Package)
  
  #------------------------ INSTALLED VS CRAN SNAPSHOT -------------------------
  
  installed_pkgs_df <- installed.packages(paths$library())[, c("Package", "Version", "Priority")] %>% as_tibble()
  available_pkgs_df <- available.packages(repos = getOption("repos"))[, c("Package", "Version", "Priority")] %>% as_tibble()
  
  # List of recommended and optional packages
  rec_op_pkgs <- available_pkgs_df %>% filter(is.na(Priority) != TRUE) %>% pull(Package)
  
  # List of packages in library vs lock file (excluding recommended and option packages)
  lib_not_lock <- setdiff(library_df_pkgs, lockfile_df_pkgs) %>% setdiff(rec_op_pkgs)
  lock_not_lib <- setdiff(lockfile_df_pkgs, library_df_pkgs) %>% setdiff(rec_op_pkgs)
  
  # Installed packages vs available packages (CRAN snapshot)
  inst_vs_avail_df <- left_join(rename(installed_pkgs_df,"version_inst" = "Version") %>% select(-Priority),
                                rename(available_pkgs_df,"version_avail" = "Version"),
                                by = "Package") %>%
    mutate(version_match = version_inst == version_avail) %>%
    rename(pkg = Package, recommended_or_base = Priority)
  
  
  # Subset for mismatches
  inst_vs_avail_subset <- inst_vs_avail_df %>%
    filter(version_match == FALSE | is.na(version_match) == TRUE)
  
  version_mismatch_df <- inst_vs_avail_subset %>%
    filter(!(pkg %in% c("renv", "slushy")))
  
  #------------------------------- CREATE LISTS --------------------------------
  
  # List of packages in the config file
  config_pkgs <- config$pkgs
  
  # List of packages in the DESCRIPTION file
  desc_file <- file.path(project, "DESCRIPTION")
  desc_pkgs <- desc_get_deps(file = desc_file)$package %>% sort()
  
  # List of packages used in code files (excluding ones in Rprofile/DESCRIPTION)
  used_pkgs <- dependencies(root = project, progress = FALSE) %>%
    as_tibble() %>% 
    filter(!str_detect(Source, regex("\\.Rprofile$", ignore_case = TRUE)) &
             !str_detect(Source, regex("DESCRIPTION$", ignore_case = TRUE)) &
             !str_detect(Source, regex("renv.lock", ignore_case = TRUE)) ) %>%
    pull(Package) %>% unique() %>% sort()
  
  # List of packages added and removed
  pkgs_added <- setdiff(desc_pkgs, config_pkgs)
  pkgs_removed <- setdiff(config_pkgs, desc_pkgs)
  
  # List of DESCRIPTION package dependencies
  desc_pkg_deps <- package_dependencies(packages = desc_pkgs,
                                        db = installed.packages(),
                                        which = c("Depends", "Imports", "LinkingTo"),
                                        recursive = FALSE) %>% unlist() %>% unique() %>% sort()
  
  #------------------------------- CREATE TABLES -------------------------------
  
  # Of the DESCRIPTION packages, which are being used/not used?
  desc_pkgs_used <- intersect(desc_pkgs, used_pkgs)
  desc_pkgs_not_used <- setdiff(desc_pkgs, used_pkgs)
  
  # Table display on whether used package is in DESCRIPTION or DESCRIPTION dependency
  used_in_desc_df <- data.frame(pkg = used_pkgs) %>%
    mutate(
      in_desc_pkgs = pkg %in% desc_pkgs,
      in_desc_deps_pkgs = pkg %in% desc_pkg_deps,
      recommended_or_base = pkg %in% rec_op_pkgs
    ) %>%
    # true values in neither column are unapproved pkgs
    mutate(neither = ifelse(in_desc_pkgs == FALSE & in_desc_deps_pkgs == FALSE & recommended_or_base == FALSE, TRUE, FALSE),
           across(!all_of("pkg"), ~ ifelse(.x, "y", "n")))
  
  not_used_in_desc_or_dep <- used_in_desc_df %>% filter(neither == "y") %>% pull(pkg)
  
  #------------------------------ CONSOLE OUTPUT -------------------------------
  
  # Helper function for centering text
  center_align <- function(text, line_width) {
    padding <- line_width - nchar(text)
    left_padding <- floor(padding / 2)
    right_padding <- ceiling(padding / 2)
    return(paste0(strrep(" ", left_padding), text, strrep(" ", right_padding)))
  }

  
  # Generate the slushy log report as a variable
  summarized_report <- {
    
    # Header for Slushy Log Report
    cli_text(strrep("-", 90))
    cat_line(center_align("Slushy Log Report", 90))
    cli_text(strrep("-", 90))
    
    # Check locally installed environment matches lock file
    cli_h3("Slushy environment status")
    if (renv_status$synchronized == FALSE) {
      cli_alert_warning("Local environment is out of sync with lockfile.")
    } else {
      cli_alert_success("Local environment is in sync with lockfile.")
    }
    
    # Output table of package version mismatches excluding renv/slushy
    cli_h3("Package Version Mismatches (Installed vs CRAN Snapshot)")
    if (nrow(version_mismatch_df) > 0) {
      print(as.data.frame(inst_vs_avail_subset))
      cli_text("")
      cli_text("Note: `slushy` and `renv` are expected")
    } else {
      cli_alert_success("All installed packages align with CRAN snapshot.")
    }
    
    # Approved Packages
    cli_h3("Agreed-Upon Packages Used")
    cli_alert_info("Agreed-upon packages that are being used in code: {length(desc_pkgs_used)}")
    print(desc_pkgs_used)
    
    cli_h3("Agreed-Upon Packages Not Used")
    cli_alert_info("Agreed-upon packages that are not being used in code: {length(desc_pkgs_not_used)}")
    print(desc_pkgs_not_used)
    
    cli_h3("Changes to Agreed-Upon Packages")
    cli_alert_info("Agreed-upon packages added following slushy initialization: {length(pkgs_added)}")
    cli_ul(pkgs_added)
    cli_alert_info("Agreed-upon packages removed following slushy initialization: {length(pkgs_removed)}")
    cli_ul(pkgs_removed)
    
    # Unapproved Packages
    cli_h3("Detecting Use of Packages Outside the Agreed-Upon Set")
    cli_alert_info("Comparison of used packages to DESCRIPTION and its dependencies:")
    print(used_in_desc_df)
    cli_text("")
    cli_alert_info("Used packages that are not in the agreed-upon packages nor their dependencies:")
    print(not_used_in_desc_or_dep)
    
    cli_text("")
  }
  
  if (full_report) {
    # Full Report: Run diagnostics in addition to summarized report
    
    # Header for renv diagnostics
    cli_text(strrep("-", 90))
    cat_line(center_align("Renv Diagnostics Report", 90))
    cli_text(strrep("-", 90))
    
    cli_text("")
    renv::diagnostics()
    
    print(summarized_report)
    cli_alert_success("Full report generated successfully.")
    
  } else {
    # Summarized Report: Only the slushy log report is generated
    
    print(summarized_report)
    cli_alert_success("Summarized report generated successfully.")
    
  }
  
  invisible(NULL)
}



#' @title Convert a List to a Data Frame
#'
#' @description
#' Converts a structured list of package details into a tidy data frame for easier analysis and processing.
#'
#' @param lst List. A structured list where each element contains package details such as `Package`, `Version`, `Source`, `Repository`, `Requirements`, and `Hash`.
#'
#' @return A `data.frame` with columns:
#' \itemize{
#'   \item `Package`: Package name (character).
#'   \item `Version`: Package version (character).
#'   \item `Source`: Package source (character).
#'   \item `Repository`: Repository information (character).
#'   \item `Requirements`: Collapsed requirements as a single string (character).
#'   \item `Hash`: Package hash (character).
#' }
#'
#' @details
#' The function ensures missing fields in the input list are replaced with `NA_character_`. 
#' If `Requirements` is present, it collapses multiple entries into a single comma-separated string.
#'
#' @examples
#' \dontrun{
#' example_list <- list(
#'   list(Package = "dplyr", Version = "1.0.10", Source = "CRAN", Repository = "https://cran.r-project.org"),
#'   list(Package = "ggplot2", Version = "3.4.0", Source = "CRAN", Repository = "https://cran.r-project.org", Requirements = c("grid", "scales"))
#' )
#' 
#' lst_to_df(example_list)
#' }
#'
#' @importFrom rlang %||%
#' @keywords internal
#' 
lst_to_df <- function(lst) {
  # Check if the input is a list
  if (!is.list(lst)) stop("Input must be a list")
  
  # Extract the necessary data into a dataframe
  df <- do.call(rbind, lapply(lst, function(package) {
    data.frame(
      Package = package$Package %||% NA_character_,
      Version = package$Version %||% NA_character_,
      Source = package$Source %||% NA_character_,
      Repository = package$Repository %||% NA_character_,
      Requirements = if (!is.null(package$Requirements)) {
        paste(package$Requirements, collapse = ", ")
      } else {
        NA_character_
      },
      Hash = package$Hash %||% NA_character_,
      stringsAsFactors = FALSE
    )
  }))
  
  return(df)
}

